# PCH 内部实现

```plain
本文是对 https://clang.llvm.org/docs/PCHInternals.html 的翻译
```

本文件描述了 Clang 的预编译头（Precompiled Headers，PCH）文件和模块的设计和实现。如果你对用户接触的内容感兴趣，请参阅[用户手册](https://clang.llvm.org/docs/UsersManual.html#usersmanual-precompiled-headers)。

## 通过 Clang 使用 PCH

## 设计哲学

## AST 文件格式

```plain
译者注：要理解这一节的部分内容，需要了解常见操作系统的目标文件（Object File）格式。可以参考《程序员的自我修养》（俞甲子, 石凡, 潘爱民, 电子工业出版社, 2009）。
```

一个 clang 产生的 AST 文件就是一个带有特殊节的目标文件，这个节保存序列化的 AST，对 COFF 文件是  `clangast` 节，对 ELF 或者 Mach-O 文件是 `__clangast` 节。目标文件中的其他节（由编译目标确定）保存 AST 中定义的数据类型的调试信息。使用 libclang 的工具也可能产生没有其他调试信息节，只有序列化 AST 的裸 AST 文件。

`clangast` 节由几个不同的块组成，每个部分保存一部分 Clang 内部表示的序列化表示。每个块要么对应一个块要么对应一个 [LLVM 二进制流格式（LLVM's bitstream format）](https://llvm.org/docs/BitCodeFormat.html) 的记录。这些逻辑块的内容如下图所示。

```ascii
┌──────────────────────────┐
│    Precompiled Header    │
│   ┌──────────────────┐   │
│   │ Metadata         │   │
│   └──────────────────┘   │
│   ┌──────────────────┐   │
│   │ Source Manager   │   │
│   └──────────────────┘   │
│   ┌──────────────────┐   │
│   │ Preprocesoor     │   │
│   └──────────────────┘   │
│   ┌──────────────────┐   │
│   │ Types            │   │
│   └──────────────────┘   │
│   ┌──────────────────┐   │
│   │ Declarations     │   │
│   └──────────────────┘   │
│   ┌──────────────────┐   │
│   │ Identifier Table │   │
│   └──────────────────┘   │
│   ┌──────────────────┐   │
│   │ Method Pool      │   │
│   └──────────────────┘   │
└──────────────────────────┘
```

`llvm-objdump` 程序提供了一个 `-raw-clang-ast` 选项，用来从一个目标文件容器中提取 AST 节的二进制内容。

[`llvm-bcanalyzer`](https://llvm.org/docs/CommandGuide/llvm-bcanalyzer.html) 可以用来检验 AST 节的二进制流的真实结构。这个信息可以用来帮助理解 AST 节的结构，也可以用来隔离可进一步优化的 AST 表示的区域，比如通过引入缩写。

### 元数据块（Metadata Block）

元数据块包含几个记录，提供用以构建这个 AST 文件的信息。这个元数据主要用来验证 AST 文件的使用情景。例如，一个编译目标为 32 位 x86 平台的 PCH 文件不能用于目标是 64 位平台的编译。元数据块包含以下信息

**语言选项**。描述用于编译 AST 文件的语言方言，包括主要选项（例如 Obj-C 支持）和次要选项（例如是否支持 "//" 注释）。这个记录的内容对应 [`LangOpts`]。

**目标架构**。描述生成的 AST 文件的编译目标架构、平台和 ABI 三元组，例如 `i386-apple-darwin9`。

**AST 版本**。AST 文件格式的主要版本号和次要版本号。次要版本号变化不影响向后兼容，而主要版本号更新的编译器不能读取更旧的 PCH（反之亦反）。

**原始文件名**。用来生成 AST 文件的头文件的完整路径。

**预定义缓冲**。虽然没有明确地作为元数据的一部分，但是预定义缓冲区是用于验证 AST 文件的。预定义缓冲区本身包含了编译器生成的，根据当前目标、平台和命令行选项，用来初始化与预处理器状态的代码。例如当我们在编译没有 Microsoft 拓展的 C 程序的时候，预定义缓冲会包含 `#define __STDC__ 1`。预定义缓冲区本身存储在源代码管理块（译者注：见下一节）中，但其内容与其他元数据一起被验证。

一个链式 PCH 文件（即引用了其他 PCH 文件的 PCH 文件）或者一个模块（一个模块内可能引入其他模块）带有额外的元数据，保存当前 AST 文件所依赖的所有 AST 文件的列表。当加载当前 AST 文件的时候这些 AST 文件都会被加载。

对于链式 PCH 文件，语言选项、目标架构和预定义缓冲数据可能被这个链的末尾文件替代，因为它们总是匹配的。

### 源代码管理块（Source Manager Block）

源代码管理块保存 Clang 的 [`SourceManager`] 的序列化表示，它处理从源代码位置（表示在 Clang AST 中），到真实的源代码文件的行列位置或宏实例的映射。源代码管理块中的文件表示还包含在构建 AST 文件时（传递性地）引入的所有头文件的信息。

源代码管理块的大部分内容是关于各种文件、缓冲区和宏实例的信息，一个源代码位置可以引用这些信息。每个文件都被一个数字“文件 ID”引用，这是一个存储在源文件位置的唯一整数（从 1 开始）。Clang 将每个文件 ID 的信息序列化，还保存一个索引，把文件 ID 映射到 AST 文件中存储该文件 ID 信息的位置。与文件 ID 有关的数据只有在编译器需要的时候才会被加载，例如在发出一个包含头文件中宏实例的诊断信息时。

源代码管理块还包含构建 AST 文件时引入的所有头文件的信息。这包含头文件的控制宏的信息（例如当预处理器确定头文件的内容依赖于 `LLVM_CLANG_SOURCEMANAGER_H` 这样的宏时）。

### 预处理器块（Preprocessor Block）

预处理块保存预处理器（Preprocessor）的序列化表示。特别地，里边保存了用来构建 AST 文件所用的头文件（header）末尾定义的所有宏，以及构成每个宏的标记序列。只有当程序中第一次出现宏的名字时，才会在 AST 文件中读取宏定义。对标识符表进行查找时，才会触发这种对宏定义的惰性加载。

### 类型块（Types Block）

每一个在翻译单元中被引用的类型，在类型块中都有一个序列化表示。每一个 Clang 类型节点（`PointerType`, `FunctionProtoType` 等等）在 AST 文件中都有一个对应的记录类型。当从 AST 文件中反序列化以得到类型时，我们用这些记录类型中的信息和 AST 上下文，重新构建正确的类型节点。

每个类型都有唯一的类型 ID，这是一个整数，可以用以区分不同的类型。类型 ID 0 用来表示 Null 类型，小于 `NUM_PREDEF_TYPE_IDS` 的类型 ID 表示预定义类型（`void`, `float` ，而其他“用户定义”的类型 ID 从 `NUM_PREDEF_TYPE_IDS` 开始递增。AST 文件有一个从用户定义类型块，到这个块所依赖的序列化表示的类型块位置的，关联映射。这个机制使我们可以实现惰性序列化。当一个类型在 AST 文件中被引用的时候，这个引用使用类型 ID 左移 3 位的值。最低的 3 位用来表示 `const`, `volatile`, `restrict` 定语，和 Clang 的 [`QualType`](https://clang.llvm.org/docs/InternalsManual.html#qualtype) 一样。

### 声明块（）

### 语句和表达式（）

### 标识符表块（）

### 方法池块（）

## AST Reader 的集成点

## 链式 PCH

## 模块

## 附录

翻译名词表

* translation unit，翻译单元，见 C99
* record type，记录类型
* AST context，AST 上下文，是一个 Clang 类
* qualifier，定语，见 C99
* preprocessor，预处理器，见 C99
* header，头文件
* token sequence，标记序列，见 C99
* section，节，这是目标文件（object file）的概念
* source location，源代码位置，这是 clang 类

翻译进度

```plain
0% 通过 Clang 使用 PCH
0% 设计哲学
50% AST 文件格式
100%  元数据块（Metadata Block）
100%  源代码管理块（）
100%  预处理器块（）
100%  类型块（Types Block）
0%  声明块（）
0%  语句和表达式（）
0%  标识符表块（）
0%  方法池块（）
0% AST Reader 的集成点
0% 链式 PCH
0% 模块
```
